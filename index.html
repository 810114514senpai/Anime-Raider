<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anime-Raider (Not Recommended for Public Use)</title> <style>
        body {
            font-family: sans-serif;
            margin: 0;
            background-image: url('https://via.placeholder.com/1920x1080/000000/FFFFFF?text=Background+Image');
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            background-color: rgba(0, 0, 0, 0.5);
            color: #eee;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            /* Removed transform: scale(0.8); for better default sizing */
        }
        .overlay {
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            max-width: 600px;
            width: 100%;
            box-sizing: border-box;
        }
        .container {
            background-color: rgba(255, 255, 255, 0.1);
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        h1 {
            color: #00bfff;
            text-align: center;
            margin-bottom: 25px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #c0c0c0;
        }
        input[type="text"],
        textarea {
            width: calc(100% - 20px);
            padding: 10px;
            margin-bottom: 20px;
            border: 1px solid #555;
            border-radius: 4px;
            box-sizing: border-box;
            background-color: #333;
            color: #eee;
        }
        textarea {
            resize: vertical;
            min-height: 80px;
        }
        .slider-group {
            margin-bottom: 20px;
        }
        .slider-group label {
            margin-bottom: 5px;
        }
        .slider-group input[type="range"] {
            width: calc(100% - 20px);
            margin-top: 5px;
            -webkit-appearance: none;
            height: 8px;
            background: #555;
            border-radius: 5px;
            outline: none;
        }
        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #00bfff;
            cursor: pointer;
            box-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
        }
        .checkbox-group {
            margin-bottom: 20px;
            display: flex;
            align-items: center;
        }
        .checkbox-group input[type="checkbox"] {
            margin-right: 10px;
            transform: scale(1.2);
        }
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        button {
            background-color: #007bff;
            color: white;
            padding: 12px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            width: 100%;
            flex-grow: 1;
        }
        button:hover {
            background-color: #0056b3;
        }
        button#stopButton {
            background-color: #dc3545;
        }
        button#stopButton:hover {
            background-color: #c82333;
        }
        #status {
            margin-top: 25px;
            padding: 15px;
            border-radius: 5px;
            background-color: #e9ecef;
            color: #495057;
            word-wrap: break-word;
            white-space: pre-wrap;
            background-color: #222;
            color: #eee;
            border: 1px solid #444;
            max-height: 200px; /* Make status div scrollable */
            overflow-y: auto;
        }
        .success {
            background-color: #28a745;
            color: white;
        }
        .error {
            background-color: #dc3545;
            color: white;
        }
        .rate-limited {
            background-color: #ffc107;
            color: #343a40;
        }
    </style>
</head>
<body>
    <div class="overlay">
        <div class="container">
            <h1>Anime-Raider</h1>

            <label for="tokenInput">Discordトークン: <span style="color: red;">(警告: セキュリティ上のリスクがあります)</span></label>
            <textarea id="tokenInput" placeholder="Discordトークンを改行区切りで入力"></textarea>

            <label for="channelIdInput">チャンネルID:</label>
            <textarea id="channelIdInput" placeholder="メッセージを送信するチャンネルIDを改行区切りで入力"></textarea>

            <label for="messageInput">メッセージ:</label>
            <textarea id="messageInput" placeholder="送信するメッセージを入力"></textarea>

            <div class="slider-group">
                <label for="speedSlider">送信速度 (間隔: <span id="speedValue">1000</span> ms) - 左にすると速くなります</label> <input type="range" id="speedSlider" min="100" max="10000" value="1000" oninput="document.getElementById('speedValue').textContent=this.value">
            </div>

            <div class="slider-group">
                <label for="countSlider">送信メッセージ数: <span id="countValue">1</span></label>
                <input type="range" id="countSlider" min="1" max="50" value="1" oninput="document.getElementById('countValue').textContent=this.value">
            </div>

            <div class="slider-group">
                <label for="mentionCountSlider">ランダムメンションユーザー数: <span id="mentionCountValue">0</span></label>
                <input type="range" id="mentionCountSlider" min="0" max="10" value="0" oninput="document.getElementById('mentionCountValue').textContent=this.value">
            </div>

            <label for="mentionIdsInput">ランダムメンション用ユーザーID (カンマ区切り):</label>
            <input type="text" id="mentionIdsInput" placeholder="例: 123456789012345678,987654321098765432">

            <div class="checkbox-group">
                <input type="checkbox" id="addRandomStringCheckbox" onchange="toggleRandomStringSlider()">
                <label for="addRandomStringCheckbox">メッセージにランダムな文字列を追加</label>
            </div>

            <div class="slider-group" id="randomStringLengthGroup" style="display: none;">
                <label for="randomStringLengthSlider">ランダム文字列の長さ: <span id="randomStringLengthValue">5</span></label>
                <input type="range" id="randomStringLengthSlider" min="1" max="20" value="5" oninput="document.getElementById('randomStringLengthValue').textContent=this.value">
            </div>

            <div class="button-group">
                <button onclick="startSending()">メッセージを送信</button>
                <button id="stopButton" onclick="stopSending()" disabled>送信を停止</button>
            </div>

            <div id="status">ここに送信ステータスが表示されます。</div>
        </div>
    </div>

    <script>
        let isSending = false;
        let stopRequested = false;
        let currentIntervalId = null; // To store interval ID for clearing

        const allEmojis = [
            '😀', '😃', '😄', '😁', '😆', '😅', '😂', '🤣', '😊', '😇', '🙂', '🙃', '😉', '😌', '😍', '🥰', '😘', '😗', '😙', '😚',
            '😋', '😛', '😝', '😜', '🤪', '🤨', '🧐', '🤓', '😎', '🤩', '🥳', '😏', '😒', '😞', '😔', '😟', '😕', '🥺', '😤', '😠',
            '😡', '🤬', '🤯', '😳', '🥵', '🥶', '😱', '😨', '😰', '😥', '😢', '😭', '🤥', '🤫', '🤭','🤔', '🤐', '🤫',
            '🤢', '🤮', '🤧', '😷', '🤒', '🤕', '🤑', '🤠', '🥳', '😎', '🤓', '🧐', '🤯', '🤫', '🤔', '🤥', '😶', '😐', '😑', '😬', '🙄',
            '😤', '😠', '😡', '🤬', '😈', '👿', '💀', '☠️', '💩', '🤡', '👹', '👺', '👻', '👽', '👾', '🤖', '😺', '😸', '😹', '😻',
            '😼', '😽', '🙀', '😿', '😾', '👋', '🤚', '🖐️', '✋', '🖖', '👌', '🤏', '✌️', '🤞', '🤙', '🤘', '🤟', '👏', '🙌', '👐',
            '🤲', '🤝', '🙏', '✍️', '💅', '🤳', '💪', '🦵', '🦶', '👂', '👃', '🧠', '🫀', '🫁', '🦷', '🦴', '👀', '👁️', '👅', '👄',
            '💋', '🩸', '🦠', '🩻', '💉', '💊', '🩹', '🩼', '🩱', '🩲', '🩳', '🩴', '👙', '👚', '👕', '👖', '👟', '👞', '👠', '👡',
            '👢', '🥿', '🩰', '🎩', '👑', '👒', '🎓', '🧢', '🎗️', '🎽', '🧣', '🧤', '🧥', '🧦', '👗', '👘', '🥻', '🩱', '🩲', '🩳',
            '🩴', '👙', '💼', '🎒', '👜', '👛', '👝', '🛍️', '🛒', '🎁', '🎀', '🎈', '🎉', '🎊', '🎋', '🎍', '🎎', '🎏', '🎐', '🎑',
            '🧧', '🎇', '🎆', '💫', '🌟', '✨', '⚡', '🔥', '💥', '☄️', '☀️', '🌞', '🌛', '🌜', '🌑', '🌓', '🌔', '🌕', '🌖',
            '🌗', '🌘', '🌙', '🌎', '🌍', '🌏', '🌐', '🗺️', '🗾', '🧭', '🏔️', '⛰️', '🌋', '🗻', '🏕️', '🏖️', '🏜️', '🏝️', '🏞️', '🛣️'
        ];

        function generateRandomString(length) {
            const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            let result = '';
            for (let i = 0; i < length; i++) {
                result += characters.charAt(Math.floor(Math.random() * characters.length));
            }
            return result;
        }

        function getRandomEmoji() {
            return allEmojis[Math.floor(Math.random() * allEmojis.length)];
        }

        function toggleRandomStringSlider() {
            const checkbox = document.getElementById('addRandomStringCheckbox');
            const sliderGroup = document.getElementById('randomStringLengthGroup');
            if (checkbox.checked) {
                sliderGroup.style.display = 'block';
            } else {
                sliderGroup.style.display = 'none';
            }
        }

        // Function to append text to status div and scroll to bottom
        function updateStatus(message, className = '') {
            const statusDiv = document.getElementById('status');
            statusDiv.textContent += (statusDiv.textContent ? '\n' : '') + message;
            statusDiv.className = className;
            statusDiv.scrollTop = statusDiv.scrollHeight; // Scroll to bottom
        }

        function stopSending() {
            stopRequested = true;
            updateStatus("\n\n--- 送信停止リクエストを受信しました。現在の処理が完了次第停止します。 ---");
            document.querySelector('button').disabled = false;
            document.getElementById('stopButton').disabled = true;
        }

        async function startSending() {
            if (isSending) {
                alert("すでにメッセージ送信中です。");
                return;
            }

            const tokensRaw = document.getElementById('tokenInput').value;
            const channelIdsRaw = document.getElementById('channelIdInput').value;
            const baseMessage = document.getElementById('messageInput').value;
            // The speed slider value directly becomes the interval.
            // Minimum is 100ms, maximum is 10000ms.
            const sendInterval = parseInt(document.getElementById('speedSlider').value, 10); 
            
            const messageCount = parseInt(document.getElementById('countSlider').value, 10);
            const mentionCount = parseInt(document.getElementById('mentionCountSlider').value, 10);
            const mentionIdsRaw = document.getElementById('mentionIdsInput').value;
            const addRandomString = document.getElementById('addRandomStringCheckbox').checked;
            const randomStringLength = parseInt(document.getElementById('randomStringLengthSlider').value, 10);
            
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = ''; // Clear previous status

            const tokens = tokensRaw.split('\n').map(t => t.trim()).filter(t => t.length > 0);
            const channelIds = channelIdsRaw.split('\n').map(id => id.trim()).filter(id => id.length > 0);
            const mentionIds = mentionIdsRaw.split(',').map(id => id.trim()).filter(id => id.length > 0);

            if (tokens.length === 0) {
                updateStatus('エラー: Discordトークンを入力してください。', 'error');
                return;
            }
            if (channelIds.length === 0) {
                updateStatus('エラー: チャンネルIDを入力してください。', 'error');
                return;
            }
            if (!baseMessage) {
                updateStatus('エラー: 送信するメッセージを入力してください。', 'error');
                return;
            }

            isSending = true;
            stopRequested = false;
            updateStatus('送信を開始します...');
            document.querySelector('button').disabled = true;
            document.getElementById('stopButton').disabled = false;

            let successfulSends = 0;
            let failedSends = 0;
            let rateLimitedCount = 0;
            let currentTokenIndex = 0;

            for (let i = 0; i < messageCount; i++) {
                if (stopRequested) {
                    updateStatus(`\n\n--- 送信がユーザーによって停止されました ---\n合計送信試行数: ${i * channelIds.length}\n成功: ${successfulSends}\n失敗: ${failedSends}\nレートリミット遭遇: ${rateLimitedCount}`);
                    break;
                }

                const currentToken = tokens[currentTokenIndex];

                for (const channelId of channelIds) {
                    if (stopRequested) {
                        updateStatus(`\n\n--- 送信がユーザーによって停止されました ---\n合計送信試行数: ${i * channelIds.length}\n成功: ${successfulSends}\n失敗: ${failedSends}\nレートリミット遭遇: ${rateLimitedCount}`);
                        break;
                    }

                    let messageToSend = baseMessage;

                    if (mentionIds.length > 0 && mentionCount > 0) {
                        const shuffledMentionIds = [...mentionIds].sort(() => 0.5 - Math.random());
                        const selectedMentions = shuffledMentionIds.slice(0, Math.min(mentionCount, mentionIds.length));
                        messageToSend += selectedMentions.map(id => ` <@${id}>`).join('');
                    }

                    if (addRandomString) {
                        messageToSend += ` ${generateRandomString(randomStringLength)}`;
                    }

                    messageToSend += ` ${getRandomEmoji()}`;

                    const headers = {
                        "Authorization": currentToken,
                        "Content-Type": "application/json",
                    };

                    const data = {
                        "content": messageToSend,
                        "tts": false
                    };

                    try {
                        const response = await fetch(`https://discord.com/api/v9/channels/${channelId}/messages`, {
                            method: 'POST',
                            headers: headers,
                            body: JSON.stringify(data)
                        });

                        const responseText = await response.text();

                        if (response.ok) {
                            successfulSends++;
                            updateStatus(`[+] (${i + 1}/${messageCount}) チャンネル ${channelId} にメッセージを送信しました。(トークン: ${currentTokenIndex + 1}/${tokens.length})\n成功: ${successfulSends}, 失敗: ${failedSends}, レートリミット: ${rateLimitedCount}`, 'success');
                        } else if (response.status === 429) {
                            rateLimitedCount++;
                            const retryAfter = response.headers.get('Retry-After');
                            updateStatus(`[!] (${i + 1}/${messageCount}) チャンネル ${channelId} でレートリミットに達しました。(トークン: ${currentTokenIndex + 1}/${tokens.length}) ${retryAfter ? retryAfter + '秒後に再試行します。' : ''}\n成功: ${successfulSends}, 失敗: ${failedSends}, レートリミット: ${rateLimitedCount}\nエラー詳細: ${responseText}`, 'rate-limited');
                            if (retryAfter) {
                                await new Promise(resolve => setTimeout(resolve, parseInt(retryAfter, 10) * 1000 + 100));
                            }
                        } else {
                            failedSends++;
                            updateStatus(`[-] (${i + 1}/${messageCount}) チャンネル ${channelId} へのメッセージ送信に失敗しました。ステータス: ${response.status} エラー: ${responseText}\n成功: ${successfulSends}, 失敗: ${failedSends}, レートリミット: ${rateLimitedCount}`, 'error');
                        }
                    } catch (error) {
                        failedSends++;
                        updateStatus(`[-] (${i + 1}/${messageCount}) ネットワークエラーまたは予期せぬエラーが発生しました: ${error.message}\n成功: ${successfulSends}, 失敗: ${failedSends}, レートリミット: ${rateLimitedCount}`, 'error');
                        console.error("Fetch error:", error);
                    }
                    if (!stopRequested) { // Only wait if not stopping
                        await new Promise(resolve => setTimeout(resolve, sendInterval));
                    }
                }
                currentTokenIndex = (currentTokenIndex + 1) % tokens.length;
            }

            if (!stopRequested) {
                updateStatus(`\n\n--- 送信完了 ---\n合計送信試行数: ${messageCount * channelIds.length}\n成功: ${successfulSends}\n失敗: ${failedSends}\nレートリミット遭遇: ${rateLimitedCount}`);
            }
            
            isSending = false;
            document.querySelector('button').disabled = false;
            document.getElementById('stopButton').disabled = true;
        }
    </script>
</body>
</html>
